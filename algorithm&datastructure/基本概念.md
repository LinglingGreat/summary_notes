# 时间复杂度

$O(f(n))$

$O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

O代表了运行时间函数的一个渐进上界，即T(n)在数量级上小于等于f(n)

计算算法复杂度大O的方法

一、得出运行时间的函数                              

二、对函数进行简化                                    

①用常数1来取代运行时间中所有加法常数  

②修改后的函数中，只保留最高阶项            

③如果最高阶项存在且不是1，则忽略这个项的系数 

==**下面说法错误的是()**==
(1)算法原地工作的含义是指不需要任何额外的辅助空间
(2)在相同的规模 n 下,复杂度 O(n)的算法在时间上总是优于复杂度 O(2n )的算法
(3)所谓时间复杂度是指最坏情况下,估算算法执行时间的一个上界
(4)同一个算法,实现语言的级别越高,执行效率就越低
A.1
B.1,2
C.1,4
D.3
答案：A
解析：
算法原地工作的含义是指不需要任何额外的辅助,算法所需要的辅助空间不随着问题的规模而变化，是一个确定的值。所以 A 不正确。

## 复杂度分析

**为什么需要复杂度分析？**

把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存，这种事后统计法的评估算法执行效率的方法是正确的，但是这种统计方法有非常大的局限性。

1.测试结果非常依赖测试环境

硬件的不同会对测试结果有很大的影响，比如不同处理器下的速度不一样，不同机器对两端代码的执行速度比较的结果可能截然相反。

2.测试结果受数据规模的影响很大

比如对于一个排序算法，待排序数据的有序度不一样，测试数据规模不一样都会导致执行时间的差异。如果测试数据规模太小，测试结果可能无法真实地反映算法的性能，比如小规模下插入排序可能比快速排序快。

**大O复杂度表示法**

算法的执行效率就是算法代码执行的时间（粗略地说）。

所有代码的执行时间T(n)与每行代码的执行次数n成正比。

T(n)=O(f(n))

f(n)表示每行代码执行的次数总和，O表示代码的执行时间T(n)与f(n)表达式成正比。

比如T(n)=O(2n+2)，T(n)=O(2n^2+2n+3)。

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

当n很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略，只需要记录一个最大量级。比如上述的可以记为T(n)=O(n)，T(n)=O(n^2)

**时间复杂度分析**

实用的方法：

1.只关注循环执行次数最多的一段代码

2.加法法则：总复杂度等于量级最大的那段代码的复杂度

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)\*T2(n)=O(f(n))\*O(g(n))=O(f(n)*g(n)).

```
1int cal(int n) {
2   int ret = 0; 
3   int i = 1;
4   for (; i < n; ++i) {
5     ret = ret + f(i);
6   } 
7 } 
8 
9 int f(int n) {
10  int sum = 0;
11  int i = 1;
12  for (; i < n; ++i) {
13    sum = sum + i;
14  } 
15  return sum;
16 }
```

这里T(n)=T1(n)\*T2(n)=O(n*n)=O(n^2)

**复杂度量级**

- 常量阶O(1)：一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行代码，其时间复杂度也是O(1)

- 对数阶O(logn)：不管以2为底，以3为底，还是以10为底，可以把所有对数阶的时间复杂度都记为O(logn)，对数之间是可以相互转换的，转换成常量系数乘以对数

- 线性阶O(n)

- 线性对数阶O(nlogn)

- 平方阶O(n^ 2)，立方阶O(n^ 3)，...k次方阶O(n^k)

- 指数阶O(2 ^n)

- 阶乘阶O(n!)

后面两个是非多项式量级，其它都是多项式量级

时间复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Polynomial，非确定多项式)问题。

另外还有O(m+n)、O(m*n)

**空间复杂度分析**

空间复杂度全称是渐进空间复杂度(asymptotic space complexity)，表示算法的存储空间与数据规模之间的增长关系。

常见的空间复杂度是O(1)、O(n)、O(n^2)等。

**最好、最坏、平均时间复杂度**

平均时间复杂度需要考虑每种情况的概率（可以简单假设一下），所以全称是叫加权平均时间复杂度或者期望时间复杂度。

**均摊时间复杂度**

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

**递归的时间复杂度**

一般地，当递归方程为T(n) = aT(n/c) + O(n), T(n)的解为： 
O(n) (a<c && c>1) 
O(nlog2n) (a=c && c>1) //以2为底 
O(nlogca) (a>c && c>1) //n的(logca)次方，以c为底 





