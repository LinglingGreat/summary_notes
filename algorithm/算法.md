# 字典序算法

算法题目：**

给定一个正整数，实现一个方法来求出离该整数最近的大于自身的“换位数”。

什么是换位数呢？就是把一个整数各个数位的数字进行全排列，从而得到新的整数。例如53241和23541。

小灰也不知道这种经过换位的整数应该如何称呼，所以姑且称其为“换位数”。

题目要求写一个方法来寻找最近的且大于自身的换位数。比如下面这样： 

输入**12345**，返回**12354**

输入**12354**，返回**12435**

输入**12435**，返回**12453**



一个数和它最近的换位数存在什么关联？如何找到离它最近且大于它的换位数呢？

为了和原数接近，我们需要**尽量保持高位不变，低位在最小的范围内变换顺序**。

那么，究竟需要变换多少位呢？这取决于当前整数的**逆序区域**。

比如12354的逆序区域是最后两位。若想最接近原数，又比原数更大，必须从**倒数第3位**开始改变。

怎样改变呢？12345的倒数第3位是3，我们需要从后面的逆序区域中寻找到刚刚大于3的数字，和3的位置进行互换

互换后的临时结果是12453，倒数第3位已经确定，这时候最后两位仍然是逆序状态。我们需要把最后两位**转变回顺序**，以此保证在倒数第3位数值为4的情况下，后两位尽可能小

这样一来，我们就得到了想要的结果**12435**。



**获得最近换位数的三个步骤：**

1.从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的边界

2.把逆序区域的前一位和逆序区域中刚刚大于它的数字交换位置

3.把原来的逆序区域转为顺序

代码实现

```c
//主流程，返回最近一个大于自身的相同数字组成的整数。
public static int[] findNearestNumber(int[] numbers){
    //拷贝入参，避免直接修改入参
   int[] numbersCopy = Arrays.copyOf(numbers, numbers.length);
	    //1.从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的边界
   int index = findTransferPoint(numbersCopy);
    //如果数字置换边界是0，说明整个数组已经逆序，无法得到更大的相同数字组成的整数，返回自身
   if(index == 0){
        return null;
	    }
    //2.把逆序区域的前一位和逆序区域中刚刚大于它的数字交换位置
   exchangeHead(numbersCopy, index);
	    //3.把原来的逆序区域转为顺序
   reverse(numbersCopy, index);
   return numbersCopy;
}

private static int findTransferPoint(int[] numbers){
    for(int i=numbers.length-1; i>0; i--){
        if(numbers[i] > numbers[i-1]){
            return i;
        }
   }
    return 0;
}
	
private  static int[] exchangeHead(int[] numbers, int index){
	    int head = numbers[index-1];
   for(int i=numbers.length-1; i>0; i--){
       if(head < numbers[i]){
            numbers[index-1] =  numbers[i];
            numbers[i] = head;
            break;
	        }
    }
   return numbers;
}

private static int[] reverse(int[] num, int index){
   for(int i=index,j=num.length-1; i<j; i++,j--){
	        int temp = num[i];
	        num[i] = num[j];
        num[j] = temp;
    }
   return num;
}

public static void main(String[] args) {
    int[] numbers = {1,2,3,4,5};
    for(int i=0; i<10;i++){
        numbers = findNearestNumber(numbers);
        outputNumbers(numbers);
    }
}

//输出数组
private static void outputNumbers(int[] numbers){
    for(int i : numbers){
        System.out.print(i);
    }
    System.out.println();
}
```

这种解法拥有一个高大上的名字：**字典序算法**。

三个步骤的每一步都是O(n)，所以整体时间复杂度也是O(n)

# 插入排序

插入排序是一种比较简单直观的排序算法，适用处理数据量比较少或者部分有序的数据

所谓直接插入排序，就是把未排序的元素一个一个地插入到有序的集合中，插入时，把有序集合从后向前扫一遍，找到合适的位置插入

代码实现

```c
public static void insertionSort(int []arr){
    for (int i=1;i<arr.length;i++){
        //将arr[i]插入到正确的位置
        insertToRightPosition(arr, i);
    }
}

private static void insertToRightPosition(int[] arr, int i){
    // 备份待插元素
    int inserted = arr[i];
    int j = i-1;
    for (;j>=0 && arr[j]>inserted;j--){
        arr[j+1] = arr[j]; // 将比待插元素大的元素后移
    }
    // 将待插元素插入正确的位置
}
```

下面讨论最坏时间复杂度，即所有元素倒序

对于n个元素，外层for循环要循环n-1次，从1到arr.length-1，insertToRightPosition里的内层for循环的循环次数是根据i来决定的，i=1时，循环1次，...，i=n-1，循环n-1次，总共加起来就是$1+2+...+(n-1) = \frac{n(n-1)}2 = \frac12 n^2 - \frac12 n$ 次，根据复杂度计算规则，保留高阶项，并去掉系数，那么时间复杂度为O(n^2)

算法稳定性

是稳定的，因为在比较的时候，如果两个数相等的话，不会进行移动，前后两个数的次序不会发生改变

# 冒泡排序

```c
private static void BubbleSort(int[] arr){
    int temp = 0;
    for (int i=0;i<arr.length-1;i++){ //一共n-1趟
        for (int j=0;j<arr.length-1-i;j++){ //第i+1趟时，一共需要比较多少次
            if (arr[j]>arr[j+1]){
                temp=arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

时间复杂度：

$(n-1)+(n-2)+...+2+1=\frac{n(n-1)}2=\frac12 n^2-\frac12n$

复杂度是$O(n^2)$

稳定性

稳定性，其实就是说，当你原来待排的元素中间有相同的元素，在没有排序之前它们之间有先后顺序，在排完后它们之间的先后顺序不变，我们就称这个算法是稳定的

冒泡排序是一个稳定的排序。

# 希尔排序

希尔排序（ShellSort）是以它的发明者Donald Shell名字命名的，希尔排序是插入排序的改进版，实现简单，对于中等规模数据的性能表现还不错。而插入排序在小规模数据数据或者基本有序或者时十分高效。

首先它把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高。比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组...，这里的差值（距离）被称为增量。

每个分组进行插入排序后，各个分组就变成了有序的了（整体不一定有序），此时，整个数组变的部分有序了（有序程度可能不是很高）。

然后缩小增量为上个增量的一半:2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比较高。同理对每个分组进行排序（插入排序），使其每个分组各自有序。

最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高。同理，对这仅有的一组数据进行排序，排序完成。

对各个组进行插入的时候并不是先对一个组进行排序完再对另一个组进行排序，而是轮流对每个组进行插入排序。

**复杂度**

希尔排序的复杂度和增量序列是相关的

{1,2,4,8,...}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是O(n^2)

Hibbard提出了另一个增量序列{1,3,7，...,2^k-1}，这种序列的时间复杂度(最坏情形)为O(n^1.5)

Sedgewick提出了几种增量序列，其最坏情形运行时间为O（n^1.3）,其中最好的一个序列是{1,5,19,41,109,...}

对不同增量的复杂度感性趣可以参考《数据结构与算法分析》一书或其他相关论文

**稳定性**

不是稳定的，虽然插入排序是稳定的，但是希尔排序在插入的时候是跳跃性插入的，有可能破坏稳定性.

代码实现

```c
private static void shellSort(int[] arr){
    int N = arr.length;
    // 进行分组，最开始时的增量(gap)为数组长度的一半
    for(int gap = N/2; gap>0; gap /= 2){
        //对各个分组进行插入排序
        for (int i=gap; i<N; i++){
            //将arr[i]插入到所在分组的正确位置上
            insertI(arr, gap, i);
        }
    }
}

/**
 * 将arr[i]插入到所在分组的正确位置上
 * arr[i]所在分组为：
 * ...arr[i-2*gap]、arr[i-gap]、arr[i]、arr[i+gap]、arr[i+2*gap]...
 */
private static void insertI(int[] arr, int gap, int i){
    int inserted = arr[i];
    int j;
    // 插入的时候按组进行插入(组内元素两两相隔gap)
    for (j=i-gap;j>=0&&inserted<arr[j];j-=gap){
        arr[j+gap] = arr[j];
    }
    arr[j+gap]=inserted;
}
```



#参考

字典序算法：

https://mp.weixin.qq.com/s/v-a2Fbiw7M3sDxvvNoXJCA

插入排序：

https://mp.weixin.qq.com/s/36sux9cAfBls0rEvBqc5-w

希尔排序

https://mp.weixin.qq.com/s/hGD4iZza5XsRiool6ZTMEw



